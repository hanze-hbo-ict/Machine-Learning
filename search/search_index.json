{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welkom bij Machine Learning","text":"<p>Hier vindt u de stof (per week) en de opgaven (per blok van twee weken).</p>"},{"location":"index.html#deel-1","title":"Deel 1","text":"<ul> <li>Week 1</li> <li>Week 2</li> <li>Inlevermoment</li> </ul>"},{"location":"index.html#deel-2","title":"Deel 2","text":"<ul> <li>Week 3</li> <li>Week 4</li> <li>Inlevermoment</li> </ul>"},{"location":"index.html#deel-3","title":"Deel 3","text":"<ul> <li>Week 5</li> <li>Week 6</li> <li>Inlevermoment</li> </ul>"},{"location":"index.html#deel-4","title":"Deel 4","text":"<ul> <li>Week 7</li> <li>Week 8</li> <li>Inlevermoment</li> </ul>"},{"location":"files/Introductie%20Pandas.html","title":"Introductie Pandas","text":""},{"location":"files/Introductie%20Pandas.html#introductie-pandas","title":"Introductie Pandas","text":""},{"location":"files/Opdracht%20model-evaluatie.html","title":"Opdracht model evaluatie","text":"<p>download de open notebook hier.</p> <pre><code>from sklearn.datasets import load_breast_cancer\nimport numpy as np\n</code></pre> <pre><code># YOUR CODE HERE\n</code></pre> <p>Maak een Support Vector Classifier met de standaard-waarden voor alle parameters. Geef dit model mee aan <code>plot_learning_curve</code> die in <code>helpers.py</code> te vinden is. Behalve dit model verwacht die methode eveneens een titel, de <code>X</code> en de <code>y</code>. De volledige signature van die methode staat hieronder; bestudeer eventueel de code om de volledige implementatie te zien.</p> <pre><code>plot_learning_curve(\n    estimator,\n    title,\n    X,\n    y,\n    axes=None,\n    ylim=None,\n    cv=None,\n    n_jobs=None,\n    scoring=\"accuracy\",\n    train_sizes=np.linspace(0.1, 1.0, 5),\n)\n</code></pre> <pre><code>from sklearn.svm import SVC\nfrom helpers import plot_learning_curve\n# YOUR CODE HERE\n</code></pre> <p>Als het goed is, heb je nu hierboven drie grafieken staan. Bedenk op basis van deze visualisatie hoe goed of hoe slecht je vindt dat je classifier werkt.</p> <p>Experimenteer vervolgens met verschillende waarden voor de parameters van die <code>SVC</code>: verander de kernel en verhoog (als je kernel <code>poly</code> is) de <code>degree</code>.  Welke verschillen zie je in de visualisatis? Kun je op basis hiervan een voorstel doen voor de beste waarden voor die parameters?</p> <p>Maak gebruik van <code>train_test_split</code> om de data op te splitsen in tachtig procent trainingsdata en twintig procent testdata.</p> <p>Train een <code>SVC</code> op basis van de beste parameters die je hierboven hebt ge\u00efdentificeerd. Maak vervolgens een confusion matrix en een classificatie-raport op basis van de testdata met dit model. Maak tenslotte een ROC-curve van dit getrainde model. </p> <p>Geef op basis hiervan een analyse van de kwaliteit van het model en een advies over hoe het model eventueel te verbeteren zou zijn.</p> <pre><code>from sklearn.model_selection import train_test_split\n# YOUR CODE HERE\n</code></pre> <pre><code>from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import ConfusionMatrixDisplay, RocCurveDisplay\n# YOUR CODE HERE\n</code></pre> <pre><code># Plot een confusion-matrix.\n# Maak gebruik van de klasse ConfusionMatrixDisplay die hierboven is ge\u00efmporteerd\n# YOUR CODE HERE\n</code></pre> <pre><code># Plot een ROC-curve.\n# Maak gebruik van de klasse RocCurveDisplay die hierboven is ge\u00efmporteerd\n# YOUR CODE HERE\n</code></pre> <pre><code>import pandas as pd\nimport numpy as np\n%matplotlib inline\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\nfrom sklearn.metrics import roc_curve, roc_auc_score\n\n# DataFrame om de gevonden metrieken per classifier in op te slaan.\nresult_table = pd.DataFrame(columns=['classifiers', 'fpr','tpr','auc'])\n\n# YOUR CODE HERE\n</code></pre> <p>In de cel hieronder wordt de variabele <code>result_table</code> gebruikt om de verschillende ROC's in \u00e9\u00e9n figuur te plotten. Je hoeft hiervoor niks te programmeren; als je de cel runt krijgt je als het goed is direct de juiste visualisatie. </p> <p>Kun je op basis van deze visualisatie een uitspraak doen over welk model de beste performance heeft voor deze dataset? </p> <pre><code>import matplotlib.pyplot as plt\nfig = plt.figure(figsize=(8,6))\n\nfor i in result_table.index:\n    plt.plot(result_table.loc[i]['fpr'], \n             result_table.loc[i]['tpr'], \n             label=f\"{i}, AUC={result_table.loc[i]['auc']:.3f}\")\n\nplt.plot([0,1], [0,1], color='orange', linestyle='--')\n\nplt.xticks(np.arange(0.0, 1.1, step=0.1))\nplt.xlabel(\"False Positive Rate\", fontsize=15)\n\nplt.yticks(np.arange(0.0, 1.1, step=0.1))\nplt.ylabel(\"True Positive Rate\", fontsize=15)\n\nplt.title('ROC Curve Analysis', fontweight='bold', fontsize=15)\nplt.legend(prop={'size':13}, loc='lower right')\n\nplt.show()\n</code></pre>"},{"location":"files/Opdracht%20model-evaluatie.html#opdracht-model-evaluatie","title":"Opdracht model-evaluatie","text":""},{"location":"files/Opdracht%20model-evaluatie.html#opdracht-1","title":"Opdracht 1","text":"<p>Laad de borstkanker-dataset en maak gebruik van <code>DESCR</code> om een beeld te krijgen van de gegevens die in deze dataset zijn opgeslagen. zorg ervoor dat je de features in een variabele <code>X</code> krijgt en de targets in de variabele <code>y</code> (dit kan op minimaal twee manieren). Je hoeft voor deze opgave geen EDA te maken of de data helemaal op te schonen (mag natuurlijk wel).</p> <p>Je hoeft het niet allemaal in \u00e9\u00e9n cel te doen; voel je vrij om meer cellen aan te maken wanneer je dat wilt.</p>"},{"location":"files/Opdracht%20model-evaluatie.html#opdracht-2","title":"Opdracht 2","text":"<p>Maak en train nu verschillende andere typen classifiers (een aantal is hieronder gegeven, maar voel je vrij om een andere set te gebruiken). Let op: alle classifiers in sklearn implementeren dezelfde interface: maak hiervan gebruik in je realisatie.</p> <p>In de cel hieronder wordt een DataFrame <code>result_table</code> gedefinieerd. Het is de bedoeling dat je van alle classifiers die je gebruikt en traint de <code>fpr</code>, de <code>tpr</code> en de <code>auc</code> in dit DataFrame opslaat. Je kunt hiervoor gebruik maken van de sklearn-methoden <code>roc_curve</code> en <code>roc_auc_score</code>. </p>"},{"location":"files/intro%20notebook%20en%20sklearn.html","title":"Intro notebook en sklearn","text":"<p>Download de jupyter notebook hier.</p> <p>Zoals tijdens het theoriecollege is toegelicht, maken we vanaf deze week gebruik van Jupyter Notebooks, een feitelijke standaard voor het rapid prototyping van machine learning projecten. Het grote voordeel van notebooks is dat je de documentatie (in markdown) direct tussen je runbare code hebt staan. Hoewel oorspronkelijk ontwikkeld voor Python zijn er inmiddels voor de meeste talen kernels ontwikkeld, zodat je ook Java, Go of PHP in notebooks kunt schrijven.</p> <p>Een tweede stap die we nu gaan zetten in gebruik maken van een bibliotheek om het zware werk voor ons over te nemen: skikit learn. Tot nu toe schreven we alle code zelf, maar in het echt maak je gebruik van deze bibliotheek: die is sneller en makkelijker en stelt je in staat om je te richten op het maken en beoordelen van modellen in plaats van het goedlaten werken van feitelijk vrij triviale programmacode.</p> <p>E\u00e9n van de voordelen van sklearn is dat de meest gebruikte datasets standaard in deze bibliotheek zitten. Veel van de voorbeelden waar we de voorbije weken mee gewerkt hebben, zul je hierin terugvinden.</p> <p>In deze opgave maken we gebruik van de California Housing dataset. Run de volgende cel om de methode te importeren die deze dataset kan laden. Bestudeer de documentatie om te weten te komen wat er in deze dataset is opgeslagen en hoe je vervolgens de data daadwerkelijk laadt. </p> <pre><code># https://stackoverflow.com/a/49174340\n# Haal de onderstaande regel uit het commentaar als je SSL-errors krijgt:\n# ssl._create_default_https_context = ssl._create_unverified_context\nfrom sklearn.datasets import fetch_california_housing\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>Gebruik de onderstaande cel om de methode <code>fetch_california_housing</code> aan te roepen. Mocht je bij het laden SSL-errors krijgen, probeer dan de eerste regel in de bovenstaande cel uit het commentaar te halen en run die cel nogmaals. Gebruik <code>feature_names</code> om de namen van de eigenschappen van de dataset te weten te komen. Zorg ervoor dat je de data van het resultaat in een variabele <code>X</code> zet, en de target in een variabele <code>y</code>.</p> <pre><code># YOUR CODE HERE\n</code></pre> <p>Zoals altijd maken we ook een paar visualisaties van de data om een beeld te krijgen van wat er zoal in zit. We beginnen met een scatter-plot; alleen dit keer plotten we niet de \\(y\\)-vector tegen een eigenschap uit de \\(X\\)-matrix; omdat we weten dat we te maken hebben met geografische data, is het leuker om de lengte- en breedtegraden tegenover elkaar te plotten. Maar gebruik van <code>matplotlib.pyplot.scatter</code> om deze twee gegevens (Longitude en Latitude, respectievelijk) te plotten. Als je het goed hebt gedaan, kun je in de resulterende plot de kustlijn van Californi\u00eb herkennen.</p> <pre><code>#YOUR CODE HERE\n</code></pre> <p>Zoals je in de documentatie hebt gelezen, is de target-value de gemiddelde waarde van de huizen in die omgeving, uitgedrukt in honderdduizend dollar. Natuurlijk moeten we wat statistieken uit deze target-vector halen. Vul onderstaande cel aan, zodat de juiste waarden worden afgedrukt. Maar vervolgens gebruik van pyplot.hist om een histogram van deze data te plotten. Beargumenteer op basis van de statistische gegevens in hoeveel <code>bins</code> je deze histogram moet onderverdelen.</p> <pre><code>import statistics as st\n# YOUR CODE HERE\n# vervang '0' door de juiste code\nmin_value = 0\nmax_value = 0\nstdev = 0\ngemiddelde = 0\n\nprint ('==== DATA UIT DE TARGET-VECTOR ====')\nprint (f'Gemiddelde: {gemiddelde:&gt;10.2f}')\nprint (f'Minimum: {min_value:&gt;10.2f}')\nprint (f'Maximum: {max_value:&gt;10.2f}')\nprint (f'StdDev: {stdev:&gt;10.2f}')\n</code></pre> <p>Een belangrijke stap om een beeld te krijgen van de data in de set is door gebruik te maken van een histogram. E\u00e9n van de belangrijke vragen daarbij is in hoeveel <code>bins</code> je de data moet verdelen. Daarvoor zijn grofweg twee methoden: Sturge's Rule en Freedman-Diaconis rule. Bestudeer deze blog hierover maak beide histogrammen. Let op dat het aantal <code>bins</code> een geheel getal moet zijn.</p> <p>Als het goed is, kom je in het eerste geval op 16 <code>bins</code> en in het tweede geval op 46. Welke van beide histogrammen vind je beter en waarom?</p> <pre><code># histogram met Sturge's Rule\nm,n = X.shape\n\n# YOUR CODE HERE\n</code></pre> <pre><code># histogram met Freedman-Diaconis rule\nm,n = X.shape\n\n# YOUR CODE HERE\n</code></pre> <p>Nu gaan we de features van deze dataset gebruiken om een voorspelling te doen van de waarde van een huis. In week 1 hebben we de wiskunde daarvan helemaal uitgeprogrammeerd; nu maken we gebruik van 'sklearn.linear_model.linear_regression'.</p> <p>Verdeel de data in 20% testdata en 80% trainingsdata. Maak hiervoor gebruik van <code>train_test_split</code>. Laad de data opnieuw in met de parameter <code>return_X_y</code> op <code>True</code>, zodat je direct de features en de corresponderende targets hebt. Waarom is deze split ook al weer nodig?</p> <p>Gebruik vervolgens de methode <code>fit</code> om het model te trainen. </p> <pre><code>from sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\n#YOUR CODE HERE\n</code></pre> <p>Gebruik nu de methode <code>predict</code> om op basis van de test-data een uitspraak te doen over hoe goed het model presteert. Gebruik hiervoor de methode <code>mean_square_error</code> uit <code>sklearn.metrics</code>. Hoe vind je dat het model presteert? Wat zou je kunnen doen om het model te verbeteren?</p> <pre><code>from sklearn.metrics import mean_squared_error\n#YOUR CODE HERE\n</code></pre> <p>Bestudeer tenslotte met behulp van het <code>coef_</code>-attribuut van het getrainde model om te weten te komen wat de formule is die het model gebruikt. Welke features zijn het belangrijkst en welke minder?</p> <pre><code>#YOUR CODE HERE\n</code></pre> <pre><code>\n</code></pre>"},{"location":"files/intro%20notebook%20en%20sklearn.html#introductie-jupyter-notebook-en-scikit-learn","title":"Introductie Jupyter Notebook en Scikit-learn","text":""},{"location":"files/intro%20notebook%20en%20sklearn.html#opdracht-1-data-laden-en-inspecteren","title":"Opdracht 1: data laden en inspecteren","text":""},{"location":"files/intro%20notebook%20en%20sklearn.html#opdracht-2-lineaire-regressie","title":"Opdracht 2: Lineaire regressie","text":""},{"location":"week1/index.html","title":"Week 1: Tools en technieken","text":"<ul> <li>Jupyter Noteboook</li> <li>hele cyclus doorlopen: data cleaning and preparation</li> <li>numpy, pandas, sklearn</li> </ul>"},{"location":"week2/index.html","title":"Week 2: Lineaire regressie","text":"<ul> <li>kostenfunctie en gradient descent</li> <li>lineaire regressie</li> </ul>"},{"location":"week2/inleveren.html","title":"Inleveren deel 1","text":"<ul> <li>ScikitLearn en California Housing (prep. en lin. regressie): https://hanze-hbo-ict.github.io/OpgavenML/files/intro%20notebook%20en%20sklearn.html</li> <li>Oude set week 1: https://hanze-hbo-ict.github.io/OpgavenML/week1.html</li> </ul>"},{"location":"week3/index.html","title":"Week 3: Logistische regressie en Neurale netwerken (1)","text":"<ul> <li>logistische regressie</li> <li>neurale netwerken 1</li> </ul>"},{"location":"week4/index.html","title":"Week 4: Neurale netwerken (2)","text":"<ul> <li>neurale netwerken 2</li> </ul>"},{"location":"week4/inleveren.html","title":"Inleveren deel 2","text":"<ul> <li>Losse opgave log. regressie: nog maken</li> <li>Oude set week 2: https://hanze-hbo-ict.github.io/OpgavenML/week2.html</li> </ul>"},{"location":"week5/index.html","title":"Week 5: Model-evaluatie","text":"<ul> <li>confusion matrix</li> <li>ROC / AUC</li> </ul>"},{"location":"week6/index.html","title":"Week 6: Andere modellen","text":"<ul> <li>SVC</li> <li>k-means en DBSCAN</li> <li>beslisbomen</li> <li>Random Forest</li> </ul>"},{"location":"week6/inleveren.html","title":"Inleveren deel 3","text":"<ul> <li>Oude set week 3: https://hanze-hbo-ict.github.io/OpgavenML/week3.html (minus opgave 3)</li> <li>Oude set week 4: https://hanze-hbo-ict.github.io/OpgavenML/files/Opdracht%20model-evaluatie.html</li> <li>Opgaven SVC en DBSCAN: heeft Bart, nog vergaren</li> </ul>"},{"location":"week7/index.html","title":"Week 7: Hyperparameter tuning","text":"<ul> <li>hyperparameter tuning</li> <li>GridSearchCV</li> <li>RandomizedSearchCV</li> <li>...and their halving counterparts</li> </ul>"},{"location":"week8/index.html","title":"Week 8: Geavanceerde onderwerpen","text":"<ul> <li>large language models</li> <li>dimensionaliteitsreductie en PCA</li> <li>ensemble learning</li> <li>informatie-entropie</li> </ul>"},{"location":"week8/inleveren.html","title":"Inleveren deel 4","text":"<ul> <li>Opgave over hyperparam tuning: nog ontwikkelen</li> <li>Vrije opgave over leuke dingen: nog ontwikkelen</li> </ul>"}]}